---
layout: post
title:  "征服C指针要点" 
date:   2015-4-23
---

<p class="intro"><span class="dropcap">C</span>是什么样的语言？最近看了前桥和弥写的征服c指针.觉得这是一本不错的书,因此做了一些摘抄.也当是复习本书的内容了.</p>
###要点
- 提高编译器的警告级别。不可无视或者制止编译器的警告。
- 很幸运，操作系统可以帮助我们停止运用程序。糟糕的是，如果操作系统不能替我们终止执行应用程序，就会上演内存区域被破坏的悲剧。
- 先有“指针类型”，因为有了指针类型，所以有了“指针类型的变量”和“指针类型的值”。
- 变量不一定按照声明的顺序保存在内存中。
- 对变量使用&运算符，可以取得该变量的地址。这个地址称为指向该变量的指针。
- 指针变量`hoge_p`保存了指向其他变量的地址的情况下，可以说指向hoge"。
- 对指针变量运用*运算符，就等同于它指向的变量。`hoge_p`指向hoge,`hoge_p`就等同于hoge。
- 对指针加N,指针前进“当前指针指向的数据类型的长度*N”。
- 【非常重要！！】表达式中，数组可以解读成“指向它的初始元素的指针”。p[i]是*(p+i)的简便写法。下标运算符[]原本只有这种用法，它和数组无关。
- p[i]可以写成i[p]。
- 如果试图将数组作为函数参数进行传递，那就传递指向初始元素的指针。
- 在下面声明的形参，都具有相同的意义。`int func(int a)`、`int func(int a[])`、`int func(int a[10])`，写法2和写法3是写法1的语法糖。
- 在如今的运行环境中，应用程序面对的是虚拟地址空间。
- c有三种内存领域的寿命：
	1. 静态变量的寿命从程序运行时开始，到程序关闭时结束。
	2. 自动变量的寿命到声明该变量的语句块执行结束为止。
	3. 通过malloc()分配的领域的寿命到调用free()为止。
- 自动变量重复使用内存区域。因此自动变量的地址是不一定的。
- c语言中，通常将自动变量保存在栈中。
- 根据算法的不同，程序的处理速度会有天壤之别。所以，选择合适的算法是非常重要的。
- malloc()不是系统调用，它也不是魔法函数。
- 不要使用cfree()。
- 请谨慎使用realloc().
- 即使手工进行布局对齐，也不能提高可移植性。
- 无论是整数还是浮点小数，内存上的表现形式都随环境的不同而不同。
- 用英语来读c的声明。
- c语言中不存在多维数组。看上去像多维数组，其实是"数组的数组"。
- 从函数类型是不能派生出除了指针类型之外的其他任何类型的。从数组类型是不能派生出函数类型的。
- typedef使用和通常的标识符声明相同的方式进行解释。可是，被声明的不是变量或者函数，而是类型的别名。
- 【非常重要！！】只有在声明函数形参的情况下，inta[]和int *a才具有相同的意义。
- 不要使用强制类型转换来掩盖编译器的警告。
- 【非常重要！！】数组和指针是不同的事物。
- 如果需要通过函数返回值以外的方式返回值，将"指向T的指针"(如果想要返回的值的类型为T)作为参数传递给函数。
- 想要将类型T的数组作为参数进行传递，可以考虑传递"指向T的指针"。可是，作为被调用方是不知道数组元素个数的，所以在必要的情况下，需要使用其他方式进行参数传递。
- 在需要获得类型T的可变长数组时，可以使用malloc()来动态地给"指向T的指针"分配内存区域。但此时需要程序员自己数组的个数进行管理。
- 异常处理中使用goto,反而可以让查询更加整洁。
- 写头文件时必须遵守的原则：
	1. 所有的头文件中，必须要有防止重复"include"的保护。
	2. 所有的头文件只include自己直接依赖的头文件。
- 如果要使用strncpy(),请使用它可能会产生没有空字符结尾的字符串。
- 在函数定义的代码文件中，必须#include包含此函数自身原型声明的头文件。
- 如果调用提供了原型声明的函数，就必须#include原型声明。
    
    
